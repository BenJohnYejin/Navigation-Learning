> * 翻译自俄语文章：https://habr.com/ru/articles/274879/
> * 项目链接：https://github.com/iliasam/keyence_LK_G407_reverce

# 激光测距传感器的逆向工程

我曾经收到过一个无法使用的 [Keyence LK-G407](http://www.keyence.com/products/measure/laser-1d/lk-g3000/models/lk-g407/index.jsp) 激光测距传感器。它不仅无法使用，而且没有专门的控制装置也无法使用。不过，这个传感器的特性非常有趣：距离测量精度达到微米级，测量速度达到每秒 50 千米。因此，为了启动它，你必须对传感器本身进行大量的摆弄，在这个过程中可以获得一些宝贵的经验。

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311120942581.png" alt="image-20240311120942581" style="zoom:67%;" />

## 传感器内部有什么？

传感器的光学部分如下图所示：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311121021698.png" alt="image-20240311121021698" style="zoom:50%;" />

图中左边是激光模块，后面是光敏尺，右边是透镜和反射镜。从设计上可以看出，这种传感器可以归类为采用三角测量法测量距离的激光测距仪。这种测距仪的工作原理在这里有详细描述。原理非常简单--当激光照射物体的距离发生变化时，测距镜片与激光光斑之间的角度也会发生变化。如果在镜头焦平面上放置一个光敏尺或矩阵，就可以根据最大输出信号的位置确定这个角度。通过了解激光和透镜之间的角度和距离，就可以确定到目标物的距离。

这种方法的优点是小距离测量精度非常高，在某些条件下可以优于 0.1 微米！高速测量距离也不成问题--只需使用高速光敏尺即可。这种测距仪的电路也非常简单--因为设备中没有大的频率，信号的主要放大作用在尺子本身。但也有一个缺点--随着距离的增加，该方法的精确度会急剧下降。这种传感器使用长焦距镜头（焦距约为 150 毫米），因此为了减小传感器的尺寸，它还包括一个镜面。

现在我们来看看传感器的电子元件。下面是传感器第二部分的外观：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311121119420.png" alt="image-20240311121119420" style="zoom:50%;" />

还有 PCB 本身：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311121200213.png" alt="image-20240311121200213" style="zoom: 50%;" />

而在另一边：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311121229093.png" alt="image-20240311121229093" style="zoom:50%;" />

印刷电路板似乎有四层--大部分信号导线位于外层，电源线位于内层。正如我已经提到过的，传感器没有控制单元，没有控制单元就无法开始工作。很明显，传感器也没有原理图，我们甚至不知道电缆的引脚和传感器的电源电压。结论 - 有必要逆向设计电路。结果，我们得到了这个方案：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311121320324.png" alt="image-20240311121320324" style="zoom:50%;" />

当然，我没有绘制整个传感器电路，只绘制了与 FPGA 有关的部分。原理图上的元件编号与电路板上的编号并不一致。因此，传感器的结构图：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311121355483.png" alt="image-20240311121355483" style="zoom:50%;" />

从原理图中可以清楚地看出，整个传感器由两个芯片控制--一个 Xilinx Spartan-3A FPGA 和一个定制芯片。不过，我非常幸运--原理图显示，定制芯片只连接到 FPGA。因此，FPGA 本身就能控制传感器中的所有信号。

整个设计的关键元素是光敏尺。这把尺子显然是定制的。在显微镜下，它的一个边缘可以看到刻字：25-512、LI004-02。我猜测 512 是尺子的像素数，25 是像素宽度（以微米为单位）。后来证明，我是对的。标尺背面焊接有一块小电路板：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311121432583.png" alt="image-20240311121432583" style="zoom: 80%;" />

它包含一个运算放大器，可将来自标尺的信号增大 2 倍，还包含几个电阻和电容。该电路板与 P1 连接器相连。从原理图中可以看出，与标尺连接的信号线只有 3 条。其中一条显然是来自其输出端的模拟信号（通过单独的同轴线传输）。其余两条线是数字信号，用于控制标尺。在分析电路时，我又走运了--当电压加到电路上时，其中一条线（4）显示出 10 MHz 的频率。很明显，这条线路负责给标尺计时。显然，对标尺的所有控制都是通过其余的线路（3）进行的。我将标尺与 STM32F4 微控制器连接起来，并开始向 (3) 和 (4) 线施加不同的信号。结果发现，标尺的工作原理非常简单--只要线 (3) 上有高电平，标尺就会受光。将线（3）设置为低电平后，标尺需要 14 个时钟脉冲，然后在接下来的 512 个时钟脉冲中输出模拟信号。标尺的工作电压为 5V，而 FPGA 的工作电压为 3.3V，因此芯片 DD2 用于电平匹配。

来自标尺的模拟信号通过 VFF 传输到 DA1 芯片上的中继器。然后，信号被馈送至 PGA（带可编程增益 [AD8369](http://www.gaw.ru/html.cgi/txt/ic/Analog_Devices/amplifiers/ad8369.htm) 的放大器）。该芯片的最大增益为 40 dB，可通过编程调整，在其输入 BIT0-3 设置所需的代码。该芯片用于放大差分信号，其输出也是差分信号，因此其两个输出端都连接到运算放大器 DA4，将信号放大 2 倍，形成一个信号。

然后，模拟信号被送入 10 位 [AD9200](http://www.gaw.ru/html.cgi/txt/ic/Analog_Devices/adc/ot_1/10bit/ad9200.htm) ADC 的输入端。我在 [SDR 接收器](http://habrahabr.ru/post/204310/)中已经熟悉了这一芯片。在本例中，它被连接到数字化电压范围 - (0.5-2.5) V。ADC 输出的数字化信号被发送到 FPGA。值得注意的是 ADC 的 CLAMP 输入。该输入也由 FPGA 控制。其目的是将输入信号的恒定分量降至一定水平。

值得注意的是该 ADC 的 CLAMP 输入。该输入也由 FPGA 控制。其目的是将输入信号的恒定分量控制在一定水平。下面是数据手册中 ADC 输入级的原理图：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311121606471.png" alt="image-20240311121606471" style="zoom:67%;" />

当向 CLAMP 输入端施加高电平时，放大器输出端和 AIN 会出现与 "CLAMP IN "输入端电压相等的电压。然后，CIN 电容将充电，直至其电压等于（Uin - Uclamp_in）。之后，"CLAMP "输入被置低，放大器停止以任何方式影响 ADC。在该传感器中，"CLAMP IN "输入端连接至 ADC 的较低参考电压 +0.5V。因此，如果在 DA4 的输出端存在一些恒定分量，则可以通过 CLAMP 功能消除其对 ADC 运行结果的影响。在为 FPGA 编写了第一个测试配置后，发现确实有必要控制 CLAMP 信号，否则 ADC 输出的信号会有很大的常数分量。在我的实现过程中，我只是在 ADC 未捕获数据时将 1 加到该信号上。

从原理图中可以看出，它使用了大量的电源电压。我没有绘制传感器中包含的各种电源和各种平滑电容器的原理图。结果发现，电源线（在一个有 2 个引脚的独立连接器上）连接到一个 TPS62050 DC-DC 转换器上。它的最大电压为 10V，电子元件尚未从 6V 开始启动，因此我认为传感器的工作电压为 8V。

该模块中使用的激光二极管由安装在另一块电路板上的电子元件控制：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311121827523.png" alt="image-20240311121827523" style="zoom: 67%;" />

我没有画出这块电路板的示意图。它通过连接器 P3 与主板相连。如图所示，激光器由两条线控制。其中一条线（3）通过逆变器与 FPGA 连接，负责打开激光器--FPGA 输出端的低电平将其打开。另一条线路（4）用于调节激光功率。这是一条模拟线路，为了改变其上的电压，电路中包含了一个由 DA5-7 芯片组装而成的 DAC（我一直不明白为什么开发人员要制作如此复杂的电路，而不是使用现成的 DAC 芯片）。

众所周知，大多数 FPGA 都不包含非易失性存储器，因此 FPGA 配置必须分别存储在外部芯片中。本例中使用的是专用闪存芯片 DD3 XCF01。上电时，FPGA 会自动将配置读入内存。FPGA 本身和 XCF01 通过 JTAG 链连接，JTAG 链连接到连接器 P2。因此，可以通过该连接器对 XCF01 进行在线编程、配置 FPGA 和调试。

这样，我就了解了传感器电子元件的原理，并掌握了部分电路。现在我可以开始实验，即对 FPGA 进行编程。需要指出的是，在此之前我并没有接触过 Xilinx 公司生产的 FPGA。我也没有必要的编程器，所以我不得不结合几个开源项目[自己制作](http://we.easyelectronics.ru/plis/programmator-dlya-plis-xilinx-na-at90usb162.html)。

编程器工作正常，我可以在 FPGA 上运行简单的项目--FPGA 引脚的简单切换。但是，后来我需要与计算机通信。我不想使用 LVDS 接口（连接 LVDS 线路的端口有 2.5V 电源电压），所以我干脆剪断了连接 FPGA 和 ASIC 的两条轨道。电路板上有一个连接器，显然是为配置或测试 ASIC 而设计的，但我无法使用它，所以我也剪掉了连接它的两条轨道，并将连接器引脚连接到 FPGA 引脚上。现在，你可以将 USB-UART 适配器连接到这个连接器上。

改装后的电路板视图：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311121942604.png" alt="image-20240311121942604" style="zoom: 50%;" />

之后，我编写了一个测试 UART 的简单程序。它成功了--计算机正确接收了通过 UART 从 FPGA 传输的单字节。下一步是将数据从光敏条传输到计算机。我使用了 FPGA 程序的结构图：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311122205846.png" alt="image-20240311122205846" style="zoom: 33%;" />

ISE 中的模式视图：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311122031658.png" alt="image-20240311122031658" style="zoom: 50%;" />

顶层项目是在原理图编辑器中绘制的，其中包含的所有模块都是用 Veriolg 编写的。项目的工作原理非常简单--来自标尺的数据经 ADC 数字化后，由 FPGA 采集并存储在 RAM 中。捕捉到全部 512 个信号元素后，通过 UART 将其传输到计算机。所有数据传输完毕后，重复上述循环。本项目中的 "sensor_reader "模块控制标尺、激光和 CLAMP 信号。控制以最简单的方式实现--所有信号均由时钟计数器控制。tx_controller "模块包括一个 UART 发送器模块。该模块用于传输模块从外部存储器接收的数据。

在操作过程中，标尺上有用信号的电平可能会有很大的变化--这是由物体距离的变化和反射系数的变化造成的。如果信号太小，就无法进行测量；如果信号太大，测量精度就会显著下降。因此，必须调整模拟信号的增益。该项目最初包括一个 UART 接收器模块，可以手动改变增益，后来我去掉了它，采用了自动增益控制 - AGC。

它包括一个用于搜索最大信号的模块（"max_finder"）和 AGC 模块本身（"agc_module"）。该模块也非常简单--如果信号电平小于 170，则增益增大，如果大于 250，则增益减小。
所有模块、标尺和 ADC 的时钟频率均为 10 MHz。我将曝光时间设定为 5 µs。因此，整个曝光过程和在 FPGA 中捕获信号的时间为 (5+51) µs。数据传输时间更长--在 500000 bps 的时钟频率下，传输 512 字节需要 10 微秒，即每秒 100 次测量。

我们编写了一个简单的 C# 程序来实时查看传输的数据：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311122140388.png" alt="image-20240311122140388" style="zoom: 50%;" />

当物体沿激光束移动时，最大峰值的位置也会发生变化。由于标尺仅包含 512 个像素，因此简单计算峰值位置的测量精度较低。因此，为了更精确地测量信号峰的位置，我们必须使用重心搜索算法，这样才能以亚像素精度确定信号峰的坐标。我使用这个公式来找到峰值的重心：
$$
P=\frac{\sum_{i}^{n} \operatorname{Int}[i] \cdot i}{\sum_{i}^{n} \operatorname{Int}[i]}
$$
其中 n 为像素总数，Int[i] 为第 i 个像素的强度。

为确保信号中存在的各种噪声不会降低运算精度，只处理超过某一阈值且接近最大峰值的采样是非常有用的。当增益不足，可用信号不超过 ADC 标度的一半时，这一点尤为重要。此外，随着增益的增加，噪声电平也会增加，从而使情况更加恶化。上述方案考虑到了这一点。

在上图中，MAX POS 是根据该公式计算出的值，MAX POS F 是最近 50 次测量的平均值。如前所述，由此产生的测量频率为 100 Hz，并受到 UART 波特率的限制。不过，不一定要在计算机上处理信号，可以在 FPGA 上处理，这样可以将测量速度提高很多倍。

因此，我们为采用这种结构方案的 FPGA 开发了一个程序：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311122420102.png" alt="image-20240311122420102" style="zoom: 33%;" />

ISE 中的模式视图：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311122442830.png" alt="image-20240311122442830" style="zoom:50%;" />

正如您所看到的，其中一些模块来自于之前的项目。在本例中，"centroid_finder "模块计算信号的重心（中心点）位置。为了限制数据分析的范围，最大位置及其振幅的粗略值被传递给该模块。由于这些值只有在分析整个信号后才能计算出来（即延迟 512 个时钟脉冲），因此数字化数据必须以同样的延迟输入到 "中心点查找器 "输入端。为了将数据延迟 512 个时钟周期，使用了一个 FIFO 缓冲器。使用 "fifo_logic "模块来初始化 FIFO，如果 FIFO 没有填满，则禁止从 FIFO 读取数据。

tx_controller_3bytes "模块按顺序传输 3 个字节，第一个字节为零，其余两个字节包含计算出的重心位置。以 50000 比特/秒的速度传输 3 个字节需要 60 微秒，几乎与捕捉信号的时间相当。零字节用于数据同步，其后总是高字节。通过 UART 进行的数据传输和数据捕获由信号 "start_capture "同时启动。如果上一次传输和新的重心位置同时计算，则会产生该信号。因此，距离测量和数据传输的时间接近 60 µs，坐标测量速度为 16.6 KSPS。这比传感器制造商宣称的速度要低。虽然不清楚这个时间是如何计算出来的，因为即使 AD9200 的最高速度为 20 MSPS，从 512 个像素捕捉信号的时间也要 25.6 μs。这还没有考虑曝光时间。

正如我之前所说，这个传感器失灵了。据我所知，问题出在它被安装在一个震动很大的工业厂房里，震动导致传感器激光失效（传感器对黑暗表面不再有反应）。不幸的是，原生二极管上没有标签。我试着用购买的 5 mW 激光二极管替换激光模块中的激光二极管，但过了一会儿，二极管的强度就下降了。很有可能，激光模块的电子元件是为功率更大的二极管设计的（尽管它工作在脉冲模式，这使得平均辐射水平相当低）。为了以某种方式启动传感器，我自制了一个以持续发射模式工作的激光二极管驱动器：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311122544079.png" alt="image-20240311122544079" style="zoom: 80%;" />

传感器的原装激光二极管焊接在激光模块的金属外壳上，因此新的激光二极管必须粘在模块上。同时，使用过的二极管的整体尺寸与原装二极管的尺寸略有不同，因此我无法正确对准激光模块。这就是组装好的传感器的样子：

为了使用传感器测量距离，有必要对传感器进行校准，即确定传感器返回的结果与实际距离之间的联系规律。校准过程本身就是一系列测量，测量结果是传感器到某个物体的距离及其相应结果的集合。传感器和物体之间的距离需要非常精确地测量。为了进行校准，我制作了一个支架，其中包括一个线性编码器和激光传感器本身：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311122619501.png" alt="image-20240311122619501" style="zoom:67%;" />

距离是通过连接到编码器末端的板测量的。收集到所有数据后，就可以在 Mathcad 中进行回归分析。结果，我得到了以下表达式：

value_mm = 70.0 / Tan(-0.000277757*max_pos + 0.28355) - 366.23554

显然，表达式中的常数值取决于传感器部件的位置。部件的微小移动都会导致计算出的距离值不正确。因此，所有部件都必须牢固固定。

视频的第一部分展示了光敏尺发出的信号。可以清楚地看到，如果物体是暗的，振幅不会发生变化（由于 AGC 的作用），但噪声水平会大大增加。

在视频的第二部分，程序从传感器接收重心位置并重新计算距离。此外，从编码器接收到的物体距离值也会传送到程序中。在编码器距离下方，会显示这些距离之间的差值。您可以看到，在运动过程中，差值会超过 1 毫米（这是由于距离传输和显示的延迟造成的），但在任何距离停止时，差值都不会超过 0.03 毫米。

为了便于分析从传感器接收到的数据，我编写了一个程序，将从传感器接收到的数据保存为 wav 格式。这些文件可以在声音编辑器中打开，并可对其进行各种过滤。

例如，下面是传感器发出的信号，该信号被指向变压器供电装置的墙壁：

<img src="https://pic-bed-1316053657.cos.ap-nanjing.myqcloud.com/img/image-20240311122710165.png" alt="image-20240311122710165" style="zoom:50%;" />

您可以看到电源在接通时是如何开始振动的。我试着将传感器对准播放音乐的扬声器的音盆，经过声音编辑器处理后，确实可以听到音乐。

通过这种方式，我成功地让一个不能工作的传感器获得了新生（我可能会在未来的项目中用到它），同时也获得了使用 Xilinx FPGA 的经验。