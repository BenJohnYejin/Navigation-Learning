> 原文：[RTKLIB: Optimized Receiver Dynamics](https://rtklibexplorer.wordpress.com/2016/06/22/rtklib-optimized-receiver-dynamics/)

上一篇文章中我提到为 RTKLIB 添加了一个 "伪距动态定位模式“，它有动态定位模式的大部分优点，但计算量要小得多。但在那之后，我意识到一个更好的选择是优化现有的动态模式，以减少计算量，而不是用新的东西来取代它。这就是我将在这篇文章中讨论的内容。

首先让我们快速看一下接收机是如何动态定位的。

在卡尔曼滤计算中，每个历元有两个步骤：

* **时间更新**：卡尔曼滤波器根据前一个历元的接收机位置、自上一个历元以来所经过的时间以及已知的接收机动态情况，预测当前历元的接收机位置，并以方差的方式估计该估计的可信度。
* **量测更新**：这些预测根据来自接收器的输入测量值进行更新。对测量结果的置信度（协方差）也进行了估计，在这次更新中使用的预测和测量之间的相对权重是由协方差决定的。

在本文，我们主要关注时间更新。

如果**没有开启动态定位**，那么这**第一步时间更新就被跳过**。RTKLIB 不预测位置，而是简单地使用从伪距测量得出的粗略测量。这个测量值通常比预测位置的精度低得多，这就是为什么启用接收机动态是有必要的。

如果**开启了动态定位**，那么 RTKLIB 将为卡尔曼滤波**添加六个状态**，三个速度、三个加速度；然后，卡尔曼滤波器将使用这些接收器的速度和加速度的估计值来预测接收器在一个历元之后的位置。这些状态的更新方式与其他状态类似，但需要注意的是，与大多数状态不同，这些状态没有与之相关的直接测量。 由于在典型的 RTKLIB 应用中，相对于接收机的最大加速度而言，历元之间的时间通常相当短，因此这些预测应该是相当准确的。这些位置估计的置信度也将根据距离下一次历元的时间长度和由配置文件输入的系统噪声 `stats-prnaccelh` 和 `stats-prnaccelv ` 定义的接收机的加速特性而更新。

关于具体如何做的更多细节，让我们看一下用户手册的附录E。在E.7节中，我们找到了用于卡尔曼滤波器时间更新的矩阵：
$$
F_{k}^{k+1}=\left(\begin{array}{ccc}\boldsymbol{I}_{3 \times 3} & \boldsymbol{I}_{3 \times 3} \tau_{r} & \\ & \boldsymbol{I}_{3 \times 3} & \\ & & \boldsymbol{I}_{(3 m-3) \times(3 m-3)}\end{array}\right)
$$
更新的状态向量 $x(k+1)$，比 $x(k)$ 晚一个历元，通过 $x(k)$ 乘以该矩阵来计算。换句话说：
$$
\mathrm{x}(\mathrm{k}+1)=\mathrm{F} * \mathrm{x}(\mathrm{k})
$$
$F$ 是一个 $n*n$ 方阵，，其中 $n$ 是状态的数量。确切的状态数将取决于输入参数，但对于我的例子来说，在启用了GPS、GLONASS、SBAS和动力学的情况下，$n$ 等于 98。这是每个卫星的一个状态，加上上面提到的接收器的九个状态。将一个 $n*m$ 矩阵与一个 $m*p$ 矩阵相乘，如果没有简化计算的方法，需要做 $n*m*p$ 次乘法，在这个例子中，$98*98*1=9604$。

让我们仔细看看状态转移矩阵 $F$，。首先，注意到它和单位阵很接近，这是一个所有 $1$ 都在对角线上的矩阵、只有一个乘以 $\tau$ 的 $3*3$ 项是不在对角线上。如果不是这个项，$x(k+1)$ 将简单地等于 $x(k)$。因为我们只更新位置状态，所有的模糊度状态都应该随时间保持不变。

那么 $\tau$ 在这里做什么呢？让我们看一下 $F$ 矩阵的第一行。通过用实际数字替换符号 $I$，我们可以看到它等于 ${1 0 0 τ 0 0 ...}$，其中剩下的 92 个元素都是 0。在这种情况下，$\tau$ 是历元之间的时间差。由于前三个状态是 x、y、z 轴上的位置，后三个状态是 x、y、z 轴上的速度，所以 $F$ 的前三行对应于方程式：
$$
\begin{array}{l}\operatorname{posx}(\mathrm{k}+1)=\operatorname{posx}(\mathrm{k})+\operatorname{velx}(\mathrm{k}) * \tau \\ \operatorname{posy}(\mathrm{k}+1)=\operatorname{posy}(\mathrm{k})+\operatorname{vely}(\mathrm{k}) * \tau \\ \operatorname{posz}(\mathrm{k}+1)=\operatorname{posz}(\mathrm{k})+\operatorname{velz}(\mathrm{k}) * \tau\end{array}
$$
由于 $F$ 的其余部分是单位阵，所以其他状态的方程将更加简单，只是等于它们之前的值。

至此，以矩阵形式出现的可能有点吓人的方程，在简化为各部分时，就会变得相当简单和熟悉。

实际上，我在这里引用的文档中的 $F$ 矩阵的版本并不完全正确，可能反映了早期的版本，因为它只增加了速度状态，而没有增加加速度状态。与代码对应的 $F$ 矩阵是：
$$
F_{k}^{k+1}=\left(\begin{array}{lll}\boldsymbol{I}_{6 \times 6} & \boldsymbol{I}_{6 \times 6} \tau_{r} & \\ & \boldsymbol{I}_{3 \times 3} & \\ & & \boldsymbol{I}_{(3 m-3) \times(3 m-3)}\end{array}\right)
$$
唯一不同的是，我们在速度状态之外还增加了加速度状态，并且用加速度更新速度，就像我们用速度更新位置一样。

由于只有前九个状态被用于方程的非对角线项中，所以确实不需要乘以全部矩阵来更新状态向量。我们可以只计算前九个状态，这需要 $9*9*1$ 的乘法，然后用矩阵复制代替其余的操作，这相当于乘以单位矩阵，但每个元素只需要一个步骤，而不是 $98$ 个浮点乘法。 这就是我在代码中所做的。

从百分比上看，由于我们将浮点乘法从 $98*98$ 减少到 $9*9$，节省的计算量很大。但其实，这一步中的乘法数量原理也没多少，所以节省的计算量并不显著。

真正减少的计算量在于协方差矩阵 $P$ 的计算，这是一个类似的操作，但计算量要大得多，因为协方差矩阵是 $98*98$ 个元素，不像状态向量只有 $98*1$ 个元素。较大的尺寸是因为它包含了每个状态和其他每个状态之间的协方差（或相关性）。我们使用类似的操作和相同的状态转换矩阵 $F$，但方程变为：
$$
\mathrm{P}(\mathrm{k}+1)=\mathrm{F} * \mathrm{P}(\mathrm{k}) * \mathrm{~F}^{\prime}
$$
其中 $P$ 是协方差矩阵，而 $F'$ 是 $F$ 矩阵的转置。同样，由于 $F$ 非常接近于单位矩阵，我们可以用复制来代替大部分的乘法，然后直接计算随着状态更新而变化的少数元素。这有点复杂，因为要实现显著的节约，我们不能像对待状态向量那样只乘以一个子矩阵就了事了。相反，我们直接计算需要修改的元素。为了计算 $F*P$，原来的代码是这样的：

```c
matmul(“NN”,rtk->nx,rtk->nx,rtk->nx,1.0,F,rtk->P,0.0,FP);
```

由于 $F$ 和 $P$ 都是 $98*98$ 矩阵，这个调用需要 $98*98*98$ 即 $941192$ 个浮点乘法，每个历元时间。我用以下几行代码取代了上述的矩阵乘法：

```c
 /* P=F*P, only calc non-zero off diaganol terms to save time */
 matcpy(FP,rtk->P,rtk->nx,rtk->nx);
for (j=0;j<rtk->nx;j++)
      for (i=0;i<6;i++)
            FP[i+j*rtk->nx]+=rtk->P[i+3+j*rtk->nx]*tt;
```

这得到的答案与完全乘法相同，但只需要 $98*6$ 或 $588$ 次浮点乘法。对 $FP * F'$ 操作进行类似的替换后，每个历元又节省了近一百万次乘法。

我通过在调用状态更新函数前后增加对 `Windows timeGetTime()` 函数的调用，能够大致估计出在我的特定情况下节省了多少时间。在修改之前，状态更新大约需要 15 毫秒，约占每个历元总计算时间的$50%$。修改后，时间太小，无法测量。我还验证了这次修改后的求解结果与之前的结果相同，这也是意料之中的，因为除了计算方式，我们没有改变任何东西。

> 我以前曾将我的伪距动态功能上传到我的 GitHub 仓库中的 demo3 代码中，但随着这一变化，我觉得该功能没有任何价值，所以已经将其删除，用这个功能取代。